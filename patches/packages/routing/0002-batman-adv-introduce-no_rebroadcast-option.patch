From: Linus Lüssing <linus.luessing@web.de>
Date: Mon, 17 Jul 2017 19:07:24 +0200
Subject: batman-adv: introduce 'no_rebroadcast' option

This patch introduces a new sysfs option named "no_rebroadcast" on
a per hard interface basis. It allows manually enabling a split-horizon
like behaviour for the layer 2 multicast payload frames, in that
incoming multicast payload frames on such a hard interface are only
being rebroadcasted on all interfaces except the incoming one instead
of being rebroadcasted on all interfaces.

Such an option should only be enabled if you are certain that these
rebroadcasts are unnecessary. This is usually the case for instance
for point-to-point wifi longshots or wired links.

This option can especially safe a significant amount of upload overhead
if the neighbourhood on a link is rather large, for instance in some
transitive, symmetric VPN configurations.

Using this option wrongly will break your mesh network, use this option
wisely and at your own risk!

Signed-off-by: Linus Lüssing <linus.luessing@web.de>

diff --git a/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch b/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch
new file mode 100644
index 0000000000000000000000000000000000000000..8935096e0806ec3cb905cd7833ea64a640ef6820
--- /dev/null
+++ b/batman-adv/patches/1001-batman-adv-introduce-no_rebroadcast-option.patch
@@ -0,0 +1,174 @@
+From: Linus Lüssing <linus.luessing@web.de>
+Date: Tue, 24 Sep 2013 04:36:27 +0200
+Subject: batman-adv: introduce 'no_rebroadcast' option
+
+This patch introduces a new sysfs option named "no_rebroadcast" on
+a per hard interface basis. It allows manually enabling a split-horizon
+like behaviour for the layer 2 multicast payload frames, in that
+incoming multicast payload frames on such a hard interface are only
+being rebroadcasted on all interfaces except the incoming one instead
+of being rebroadcasted on all interfaces.
+
+Such an option should only be enabled if you are certain that these
+rebroadcasts are unnecessary. This is usually the case for instance
+for point-to-point wifi longshots or wired links.
+
+This option can especially safe a significant amount of upload overhead
+if the neighbourhood on a link is rather large, for instance in some
+transitive, symmetric VPN configurations.
+
+Using this option wrongly will break your mesh network, use this option
+wisely and at your own risk!
+
+Signed-off-by: Linus Lüssing <linus.luessing@web.de>
+
+diff --git a/Documentation/ABI/obsolete/sysfs-class-net-batman-adv b/Documentation/ABI/obsolete/sysfs-class-net-batman-adv
+index 5bdbc8d402561acb01e9722ccb11498ce9ff4b82..222c782ec5fc9e2f4f308cff71ca486182e4a319 100644
+--- a/Documentation/ABI/obsolete/sysfs-class-net-batman-adv
++++ b/Documentation/ABI/obsolete/sysfs-class-net-batman-adv
+@@ -30,3 +30,14 @@ description:
+                 when estimating the link throughput using this interface.
+                 If the value is set to 0 then batman-adv will try to
+                 estimate the throughput by itself.
++
++What:           /sys/class/net/<iface>/batman-adv/no_rebroadcast
++Date:           Sep 2013
++Contact:        Linus Lüssing <linus.luessing@web.de>
++Description:
++                With this option set incoming multicast payload frames on
++                <iface> are not being rebroadcasted on <iface> again. This
++                option should be set on links which are known to be transitive
++                and symmetric only, for instance point-to-point wifi longshots
++                or wired links. Using this option wrongly is going to
++                break your mesh network, use at your own risk!
+diff --git a/net/batman-adv/hard-interface.c b/net/batman-adv/hard-interface.c
+index 62b926dd4aaeffd82da83654c8e568de2c3714fb..b0e9b3da8866d4562c77f04a1ebf68ddb248a6ef 100644
+--- a/net/batman-adv/hard-interface.c
++++ b/net/batman-adv/hard-interface.c
+@@ -942,6 +942,8 @@ batadv_hardif_add_interface(struct net_device *net_dev)
+ 
+ 	batadv_v_hardif_init(hard_iface);
+ 
++	atomic_set(&hard_iface->no_rebroadcast, 0);
++
+ 	batadv_check_known_mac_addr(hard_iface->net_dev);
+ 	kref_get(&hard_iface->refcount);
+ 	list_add_tail_rcu(&hard_iface->list, &batadv_hardif_list);
+diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c
+index 3ce5f7bad3698f89c8190aa2d31329e0c947092a..cceaa3d4ca1d8fd06a31afe34f8b2f1f7400d779 100644
+--- a/net/batman-adv/send.c
++++ b/net/batman-adv/send.c
+@@ -932,6 +932,10 @@ static void batadv_send_outstanding_bcast_packet(struct work_struct *work)
+ 		if (neigh_node)
+ 			batadv_hardif_neigh_put(neigh_node);
+ 
++		if (atomic_read(&hard_iface->no_rebroadcast) &&
++		    forw_packet->skb->dev == hard_iface->net_dev)
++			continue;
++
+ 		if (!kref_get_unless_zero(&hard_iface->refcount))
+ 			continue;
+ 
+diff --git a/net/batman-adv/sysfs.c b/net/batman-adv/sysfs.c
+index 80fc3253c3368e3cc356176c5ba961542de0a8c9..a1d1dd8c1d394c4437e7501802158b743640833c 100644
+--- a/net/batman-adv/sysfs.c
++++ b/net/batman-adv/sysfs.c
+@@ -123,6 +123,17 @@ struct batadv_attribute batadv_attr_vlan_##_name = {	\
+ 	.store  = _store,				\
+ }
+ 
++/* Use this, if you have customized show and store functions
++ * for hard interface attrs
++ */
++#define BATADV_ATTR_HIF(_name, _mode, _show, _store)	\
++struct batadv_attribute batadv_attr_hif_##_name = {	\
++	.attr = {.name = __stringify(_name),		\
++		 .mode = _mode },			\
++	.show   = _show,				\
++	.store  = _store,				\
++};
++
+ /* Use this, if you have customized show and store functions */
+ #define BATADV_ATTR(_name, _mode, _show, _store)	\
+ struct batadv_attribute batadv_attr_##_name = {		\
+@@ -314,6 +325,52 @@ ssize_t batadv_show_##_name(struct kobject *kobj,			\
+ 	static BATADV_ATTR(_name, _mode, batadv_show_##_name,		\
+ 			   batadv_store_##_name)
+ 
++#define BATADV_ATTR_HIF_STORE_BOOL(_name, _post_func)			\
++ssize_t batadv_store_hif_##_name(struct kobject *kobj,			\
++				 struct attribute *attr, char *buff,	\
++				 size_t count)				\
++{									\
++	struct net_device *net_dev = batadv_kobj_to_netdev(kobj);	\
++	struct batadv_hard_iface *hard_iface;				\
++	size_t res;							\
++									\
++	hard_iface = batadv_hardif_get_by_netdev(net_dev);		\
++	if (!hard_iface)						\
++		return 0;						\
++									\
++	res = __batadv_store_bool_attr(buff, count, _post_func,		\
++					      attr, &hard_iface->_name,	\
++					      hard_iface->soft_iface);	\
++	batadv_hardif_put(hard_iface);					\
++	return res;							\
++}
++
++#define BATADV_ATTR_HIF_SHOW_BOOL(_name)				\
++ssize_t batadv_show_hif_##_name(struct kobject *kobj,			\
++				struct attribute *attr, char *buff)	\
++{									\
++	struct net_device *net_dev = batadv_kobj_to_netdev(kobj);	\
++	struct batadv_hard_iface *hard_iface;				\
++	size_t res;							\
++									\
++	hard_iface = batadv_hardif_get_by_netdev(net_dev);		\
++	if (!hard_iface)						\
++		return 0;						\
++									\
++	res = sprintf(buff, "%s\n",					\
++		      atomic_read(&hard_iface->_name) == 0 ?		\
++				"disabled" : "enabled");		\
++	batadv_hardif_put(hard_iface);					\
++	return res;							\
++}
++
++/* Use this, if you are going to turn a [name] in the vlan struct on or off */
++#define BATADV_ATTR_HIF_BOOL(_name, _mode, _post_func)			\
++	static BATADV_ATTR_HIF_STORE_BOOL(_name, _post_func)		\
++	static BATADV_ATTR_HIF_SHOW_BOOL(_name)				\
++	static BATADV_ATTR_HIF(_name, _mode, batadv_show_hif_##_name,	\
++			       batadv_store_hif_##_name)
++
+ static int batadv_store_bool_attr(char *buff, size_t count,
+ 				  struct net_device *net_dev,
+ 				  const char *attr_name, atomic_t *attr,
+@@ -1198,6 +1255,7 @@ static ssize_t batadv_show_throughput_override(struct kobject *kobj,
+ static BATADV_ATTR(mesh_iface, 0644, batadv_show_mesh_iface,
+ 		   batadv_store_mesh_iface);
+ static BATADV_ATTR(iface_status, 0444, batadv_show_iface_status, NULL);
++BATADV_ATTR_HIF_BOOL(no_rebroadcast, 0644, NULL);
+ #ifdef CONFIG_BATMAN_ADV_BATMAN_V
+ BATADV_ATTR_HIF_UINT(elp_interval, bat_v.elp_interval, 0644,
+ 		     2 * BATADV_JITTER, INT_MAX, NULL);
+@@ -1208,6 +1266,7 @@ static BATADV_ATTR(throughput_override, 0644, batadv_show_throughput_override,
+ static struct batadv_attribute *batadv_batman_attrs[] = {
+ 	&batadv_attr_mesh_iface,
+ 	&batadv_attr_iface_status,
++	&batadv_attr_hif_no_rebroadcast,
+ #ifdef CONFIG_BATMAN_ADV_BATMAN_V
+ 	&batadv_attr_elp_interval,
+ 	&batadv_attr_throughput_override,
+diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h
+index c0ded822517b94333451deb9c0ff4037744b1fd9..ea499de307559ae1726a7489dd1f2ab4a38c8a25 100644
+--- a/net/batman-adv/types.h
++++ b/net/batman-adv/types.h
+@@ -219,6 +219,7 @@ struct batadv_hard_iface {
+ 
+ 	/** @neigh_list_lock: lock protecting neigh_list */
+ 	spinlock_t neigh_list_lock;
++	atomic_t no_rebroadcast;
+ };
+ 
+ /**
